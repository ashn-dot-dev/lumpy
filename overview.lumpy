# This is a comment.
# Comments begin with the # character and extend until the end of the line.

println("====================");
println("== Literal Values ==");
println("====================");

dumpln( null );

print("\n");

dumpln( true  );
dumpln( false );

print("\n");

dumpln( 123    );
dumpln( 123.0  );
dumpln( 123.45 );
dumpln( 0xdeadbeef );

print("\n");

dumpln( "hello"        );
dumpln( "hello world"  );
dumpln( "hello\tworld" );
dumpln( "hello\nworld" );
dumpln( "hello\\world" );
dumpln( "hello\"world" );
dumpln( `hello world`  );
dumpln(
`hello
world`
);
dumpln(
```
hello
world
```
);

print("\n");

dumpln( []                     );
dumpln( ["foo", "bar", "baz"]  );
dumpln( ["foo", "bar", "baz",] );

print("\n");

dumpln( map{}                                    );
dumpln( map{"foo": 123, "bar": 456, "baz": 789}  );
dumpln( map{"foo": 123, "bar": 456, "baz": 789,} );
dumpln( {"foo": 123, "bar": 456, "baz": 789}     );
dumpln( {"foo": 123, "bar": 456, "baz": 789,}    );

print("\n");

dumpln( set{}                     );
dumpln( set{"foo", "bar", "baz"}  );
dumpln( set{"foo", "bar", "baz",} );
dumpln( {"foo", "bar", "baz"}     );
dumpln( {"foo", "bar", "baz",}    );

print("\n");

dumpln( 123.&                                  );
dumpln( {"foo": 123, "bar": 456, "baz": 456}.& );

print("\n");

let named_function = function() { };
dumpln( named_function                                          );
dumpln( function() { }                                          );
dumpln( function() { println("hello from inside a function"); } );

print("\n");

dumpln( dumpln  );
dumpln( println );

print("\n");

println("===============");
println("== Accessors ==");
println("===============");

let s = "hello world";
println("s is " + repr(s));
println("s[1] is " + repr(s[1]));
println("set s[0] to \"y\"");
s[0] = "y";
println("s is " + repr(s));

print("\n");

let v = [123, 456, 789];
println("v is " + repr(v));
println("v[1] is " + repr(v[1]));
try { v[3]; } else err { println("v[3] produces " + repr(err)); }
try { v["foo"]; } else err { println("v[\"foo\"] produces " + repr(err)); }

print("\n");

let m = {"foo": "bar", 123: {456, 789}, {"key": "val"}: "baz"};
println("m is " + repr(m));
println("m[\"foo\"] is " + repr(m["foo"]));
println("m[123] is " + repr(m[123]));
println("m[{\"key\": \"val\"}] is " + repr(m[{"key": "val"}]));
println("m::foo is " + repr(m::foo) + " (equivalent to m[\"foo\"])");
println("m.foo is " + repr(m.foo) + " (equivalent to m[\"foo\"] for field access)");
try { m["qux"]; } else err { println("m[\"qux\"] produces " + repr(err)); }

print("\n");

println("============================");
println("== String Value Semantics ==");
println("============================");

let s1 = "foobar";
println("s1 is " + repr(s1));
let s2 = s1;
println("let s2 be s1");
println("s2 is " + repr(s2));
println("set s2[1] to \"u\"");
s2[1] = "u";
println("s1 is " + repr(s1));
println("s2 is " + repr(s2));

print("\n");

println("============================");
println("== Vector Value Semantics ==");
println("============================");

let k = ["y", 456];
println("k is " + repr(k));
println("let v be [[\"x\", 123], k, [\"z\", 789]]");
let v = [["x", 123], k, ["z", 789]];
println("v is " + repr(v));
println("set v[1][1] to \"foo\"");
v[1][1] = "foo";
println("k is " + repr(k));
println("v is " + repr(v));

print("\n");

let v1 = [["x", 123], ["y", 456], ["z", 789]];
println("v1 is " + repr(v1));
let v2 = v1;
println("let v2 be v1");
println("v2 is " + repr(v2));
println("set v2[1][1] to \"foo\"");
v2[1][1] = "foo";
println("v1 is " + repr(v1));
println("v2 is " + repr(v2));

print("\n");

println("=========================");
println("== Map Value Semantics ==");
println("=========================");

let k = {"y": 456};
println("k is " + repr(k));
println("let m be {\"a\": {\"x\": 123}, \"b\": k, \"c\": {\"z\": 789}}");
let m = {"a": {"x": 123}, "b": k, "c": {"z": 789}};
println("m is " + repr(m));
println("set m[\"b\"][\"y\"] to \"foo\"");
m["b"]["y"] = "foo";
println("k is " + repr(k));
println("m is " + repr(m));

print("\n");

let m1 = {"a": {"x": 123}, "b": {"y": 456}, "c": {"z": 789}};
println("m1 is " + repr(m1));
println("let m2 be m1");
let m2 = m1;
println("m2 is " + repr(m2));
println("set m2[\"b\"][\"y\"] to \"foo\"");
m2["b"]["y"] = "foo";
println("m1 is " + repr(m1));
println("m2 is " + repr(m2));

print("\n");

println("=========================");
println("== Set Value Semantics ==");
println("=========================");

let k = {"b", 456};
println("k is " + repr(k));
println("let s be {{\"x\", 123}, k, {\"c\", 789}}");
let s = {{"x", 123}, k, {"c", 789}};
println("s is " + repr(s));
println("insert \"foo\" into k");
k.insert("foo");
println("k = " + repr(k));
println("s = " + repr(s));

print("\n");

println("===============");
println("== Operators ==");
println("===============");

println("operator + (unary)");
println("+123 is " + repr(+123));
println("+-123 is " + repr(+-123));

print("\n");

println("operator - (unary)");
println("-123 is " + repr(-123));
println("--123 is " + repr(--123));

print("\n");

println("operator not");
println("not true is " + repr(not true));
println("not false is " + repr(not false));

print("\n");

println("operator ==");
println("123 == 123 is " + repr(123 == 123));
println("123 == 456 is " + repr(123 == 456));
println("\"foo\" == \"foo\" is " + repr("foo" == "foo"));
println("\"foo\" == \"bar\" is " + repr("foo" == "bar"));
println("123 == \"foo\" is " + repr(123 == "foo"));

print("\n");

println("operator !=");
println("123 != 123 is " + repr(123 != 123));
println("123 != 456 is " + repr(123 != 456));
println("\"foo\" != \"foo\" is " + repr("foo" != "foo"));
println("\"foo\" != \"bar\" is " + repr("foo" != "bar"));
println("123 != \"foo\" is " + repr(123 != "foo"));

print("\n");

println("operator <=");
println("123 <= 123 is " + repr(123 <= 123));
println("123 <= 456 is " + repr(123 <= 456));
println("\"foo\" <= \"foo\" is " + repr("foo" <= "foo"));
println("\"foo\" <= \"bar\" is " + repr("foo" <= "bar"));

print("\n");

println("operator >=");
println("123 >= 123 is " + repr(123 >= 123));
println("123 >= 456 is " + repr(123 >= 456));
println("\"foo\" >= \"foo\" is " + repr("foo" >= "foo"));
println("\"foo\" >= \"bar\" is " + repr("foo" >= "bar"));

print("\n");

println("operator <");
println("123 < 123 is " + repr(123 < 123));
println("123 < 456 is " + repr(123 < 456));
println("\"foo\" < \"foo\" is " + repr("foo" < "foo"));
println("\"foo\" < \"bar\" is " + repr("foo" < "bar"));

print("\n");

println("operator >");
println("123 > 123 is " + repr(123 > 123));
println("123 > 456 is " + repr(123 > 456));
println("\"foo\" > \"foo\" is " + repr("foo" > "foo"));
println("\"foo\" > \"bar\" is " + repr("foo" > "bar"));

print("\n");

println("operator +");
println("123 + 456 is " + repr(123 + 456));
println("\"foo\" + \"bar\" is " + repr("foo" + "bar"));

print("\n");

println("operator -");
println("123 - 456 is " + repr(123 - 456));

print("\n");

println("operator *");
println("123 * 456 is " + repr(123 * 456));

print("\n");

println("operator /");
println("123 / 456 is " + repr(123 / 456));
try { 123 / 0; } else err { println("123 / 0 produces " + repr(err)); }

print("\n");

println("operator %");
println("+7 % +3 is " + repr(+7 % +3));
println("+7 % -3 is " + repr(+7 % -3));
println("-7 % +3 is " + repr(-7 % +3));
println("-7 % -3 is " + repr(-7 % -3));
println("10 % 3.5 is " + repr(10 % 3.5));
println("123 % Inf is " + repr(123 % Inf));
try { 123 % 0; } else err { println("123 % 0 produces " + repr(err)); }

print("\n");

println("operator .&");
println("123.& is " + repr(123.&));

print("\n");

println("operator .*");
println("123.&.* is " + repr(123.&.*));
println("let m be map{}");
let x = map{};
println("let y be x.&");
let y = x.&;
println("set y.*[\"foo\"] to \"bar\"");
y.*["foo"] = "bar";
println("x is " + repr(x));

print("\n");

println("operator Precedence");
let tmp = (123 + 456) * 789 + map{"x": 3.14}["x"];
println("(123 + 456) * 789 + map{\"x\": 3.14}[\"x\"] evaluates to " + repr(tmp));

print("\n");

println("==========================");
println("== Operator Overloading ==");
println("==========================");
let person = {
    "new": function(name, age) {
        let self = {"name": name, "age": age};
        setmeta(self.&, person);
        return self;
    },
    "unary+": function(value) {
        println("unary+ called with " + repr(value));
        return alice; # arbitrary
    },
    "unary-": function(value) {
        println("unary- called with " + repr(value));
        return alice; # arbitrary
    },
    "not": function(value) {
        println("not called with " + repr(value));
        return alice; # arbitrary
    },
    "and": function(lhs, rhs) {
        println("and called with " + repr(lhs) + " and " + repr(rhs));
        return false; # arbitrary
    },
    "or": function(lhs, rhs) {
        println("or called with " + repr(lhs) + " and " + repr(rhs));
        return false; # arbitrary
    },
    "==": function(lhs, rhs) {
        println("== called with " + repr(lhs) + " and " + repr(rhs));
        return lhs.name == rhs.name and lhs.age == rhs.age;
    },
    "!=": function(lhs, rhs) {
        println("!= called with " + repr(lhs) + " and " + repr(rhs));
        return not (lhs.name == rhs.name and lhs.age == rhs.age);
    },
    "<=": function(lhs, rhs) {
        println("<= called with " + repr(lhs) + " and " + repr(rhs));
        return false; # arbitrary
    },
    ">=": function(lhs, rhs) {
        println(">= called with " + repr(lhs) + " and " + repr(rhs));
        return false; # arbitrary
    },
    "<": function(lhs, rhs) {
        println("< called with " + repr(lhs) + " and " + repr(rhs));
        return false; # arbitrary
    },
    ">": function(lhs, rhs) {
        println("> called with " + repr(lhs) + " and " + repr(rhs));
        return false; # arbitrary
    },
    "+": function(lhs, rhs) {
        println("+ called with " + repr(lhs) + " and " + repr(rhs));
        return alice; # arbitrary
    },
    "-": function(lhs, rhs) {
        println("- called with " + repr(lhs) + " and " + repr(rhs));
        return alice; # arbitrary
    },
    "*": function(lhs, rhs) {
        println("* called with " + repr(lhs) + " and " + repr(rhs));
        return alice; # arbitrary
    },
    "/": function(lhs, rhs) {
        println("/ called with " + repr(lhs) + " and " + repr(rhs));
        return alice; # arbitrary
    },
    "%": function(lhs, rhs) {
        println("% called with " + repr(lhs) + " and " + repr(rhs));
        return alice; # arbitrary
    },
};

println("person is " + repr(person));

print("\n");

println("let alice be the result of person::new(\"Alice\", 32)");
let alice = person::new("Alice", 32);
println("alice is " + repr(alice));
println("getmeta(alice) is " + repr(getmeta(alice)));

print("\n");

println("let bob be the result of person::new(\"Bob\", 27)");
let bob = person::new("Bob", 27);
println("bob is " + repr(bob));
println("getmeta(bob) is " + repr(getmeta(bob)));

print("\n");

println("calling overloadable operators on alice and bob");
+alice;
-alice;
not alice;
alice and bob;
alice or bob;
alice == bob;
alice != bob;
alice <= bob;
alice >= bob;
alice < bob;
alice > bob;
alice + bob;
alice - bob;
alice * bob;
alice / bob;
alice % bob;

print("\n");

let vec2 = {
    "new": function(x, y) {
        let self = {"x": x, "y": y};
        setmeta(self.&, vec2);
        return self;
    },
    "unary+": function(value) {
        println("unary+ called with " + string(value));
        return value;
    },
    "unary-": function(value) {
        println("unary- called with " + string(value));
        value.x = -value.x;
        value.y = -value.y;
        return value;
    },
    "compare": function(lhs, rhs) {
        println("compare called with " + string(lhs) + " and " + string(rhs));
        if lhs.x < rhs.x { return -1; }
        if lhs.x > rhs.x { return +1; }
        if lhs.y < rhs.y { return -1; }
        if lhs.y > rhs.y { return +1; }
        return 0;
    },
};

println("vec2 is " + repr(vec2));

print("\n");

println("let a be the result of vec2::new(-3, +5)");
let a = vec2::new(-3, +5);
println("a is " + repr(a));
println("getmeta(a) is " + repr(getmeta(a)));

print("\n");

println("let b be the result of vec2::new(+1, +0)");
let b = vec2::new(+1, +0);
println("b is " + repr(b));
println("getmeta(b) is " + repr(getmeta(b)));

print("\n");

println("calling overloadable comparison operators on a and a");
dumpln(a == a);
dumpln(a != a);
dumpln(a <= a);
dumpln(a >= a);
dumpln(a < a);
dumpln(a > a);

print("\n");

println("calling overloadable comparison operators on a and b");
dumpln(a == b);
dumpln(a != b);
dumpln(a <= b);
dumpln(a >= b);
dumpln(a < b);
dumpln(a > b);

print("\n");

println("========================");
println("== If, Elif, and Else ==");
println("========================");

if true {
    println("A (if)");
}

if false {
    println("X");
}
elif true {
    println("B (elif)");
}

if false {
    println("X");
}
elif false {
    println("X");
}

if false {
    println("X");
}
elif false {
    println("X");
}
elif true {
    println("C (second-elif)");
}

if false {
    println("X");
}
elif false {
    println("X");
}
else {
    println("D (else)");
}

print("\n");

println("===========");
println("== Loops ==");
println("===========");

println("Integer Loop: for x in 3");
for x in 3 {
    println("x is " + repr(x));
}

print("\n");

println("Integer Loops With References Are Not Permitted: for reference x in 3");
try {
    for k.& in 3 { }
}
else err {
    println("error: " + string(err));
}

print("\n");

let v = ["a", "b", "c"];
println("Vector Loop: for x in " + repr(v));
for x in v {
    println("x is " + repr(x));
}

print("\n");

let v = [{"value": 123}, {"value": 456}, {"value": 789}];
println("Vector Loop With References: for reference x in vector " + repr(v) + " increment x.*.value by one");
for x.& in v {
    x.*.value = x.*.value + 1;
}
println("vector post-loop is " + repr(v));

print("\n");

let m = map{"a": 123, "b": 456, "c": 789};
println("Map Loop: for k, v in " + repr(m));
for k, v in m {
    println("k is " + repr(k) + ", " + "v is " + repr(v));
}

print("\n");

let m = {{"id": 123}: "foo", {"id": 456}: "bar", {"id": 789}: "baz"};
println("Map Loops With Key References Are Not Permitted: for reference k in set " + repr(m));
try {
    for k.& in m { }
}
else err {
    println("error: " + string(err));
}

print("\n");

let m = {"foo": {"value": 123}, "bar": {"value": 456}, "baz": {"value": 789}};
println("Map Loops With Value References: for k, reference v in set " + repr(m) + " increment v.*.value by one");
for k, v.& in m {
    v.*.value = v.*.value + 1;
}
println("map post-loop is " + repr(m));

print("\n");

let s = set{"a", "b", "c"};
println("Set Loop: for x in " + repr(s));
for x in s {
    println("x is " + repr(x));
}

print("\n");

let s = {{"value": 123}, {"value": 456}, {"value": 789}};
println("Set Loops With References Are Not Permitted: for reference x in set " + repr(s));
try {
    for x.& in s { }
}
else err {
    println("error: " + string(err));
}

print("\n");

println("let x be 1");
let x = 1;
println("while x <= 5 print x and then increment x by 1");
while x <= 5 {
    println("x is " + repr(x));
    x = x + 1;
}

print("\n");

println("Break: while true break");
while true {
    break;
}

print("\n");

let v = ["foo", "bar", "baz"];
println("Continue: for x in " + repr(v) + " continue before an error occurs");
for x in v {
    continue;
    error "oopsie";
}

print("\n");

println("======================================");
println("== Scoping, Functions, and Closures ==");
println("======================================");

let hello = function() {
    println("hello from inside a function");
};
hello();

print("\n");

println("let x be 123");
let x = 123;
println("open a new scope");
if true {
    println("\tlet x be 456 inside the new scope");
    let x = 456;
    println("\tinside the scope x is " + repr(x));
}
println("outside the scope x is " + repr(x) + " due to lexical scoping");

print("\n");

println("let x be 123");
let x = 123;
println("open a new scope");
if true {
    println("\tset x to 456 inside the new scope (using assignmet without let)");
    x = 456;
    println("\tinside the scope x is " + repr(x));
}
println("outside the scope x is " + repr(x));

print("\n");

println("let x be 123");
let x = 123;
function() {
    println("\tset x to 456 from within a function (using assignmet without let)");
    x = 456;
    println("\tinside the function x is " + repr(x));
}();
println("outside the function x is " + repr(x));

print("\n");

println("create a function `adder(x)` returining a `function(y)` that returns the sum of the closed-over x and argument y when invoked");
let adder = function(x) {
    return function(y) {
        return x + y;
    };
};
println("adder is " + repr(adder));
println("let add1 be adder(1)");
let add1 = adder(1);
println("add1 is " + repr(add1));
println("add1(2) is " + repr(add1(2)));

print("\n");

let x = map{
    "a": 123,
    "f": function(self) {
        println("\t[inside f] self is " + repr(self));
        println("\t[inside f] self.*.a is " + repr(self.*.a));
    },
};
println("x is " + repr(x));
println("x[\"f\"] is a function with a single `self` parameter");
println("calling x[\"f\"] as x[\"f\"](x.&)");
x["f"](x.&);
println("calling x[\"f\"] as x::f(x.&) (equivalent to the call above)");
x::f(x.&);
println("calling x[\"f\"] as x.f() (equivalent to the call above, x.& is implicitly passed as the first argument)");
x.f();

print("\n");

println("==============");
println("== Try-Else ==");
println("==============");

try { println("inside try block"); } else err { println("inside try-else block: " + err); }
try { error "some user defined error"; } else err { println("inside try-else block: " + err); }
try { let x = []; x[1]; } else err { println("inside try-else block: " + err); }
try { let x = []; x[1] = 123; } else err { println("inside try-else block: " + err); }
try { let x = map{}; x["foo"]; } else err { println("inside try-else block: " + err); }
try { let x = map{}; x["foo"] = 123; } else err { println("inside try-else block: " + err); }
try { let x = map{}; x::foo; } else err { println("inside try-else block: " + err); }
try { let x = map{}; x.foo; } else err { println("inside try-else block: " + err); }

print("\n");

println("=======================");
println("== Builtin Functions ==");
println("=======================");

println("setmeta: set the metamap of a value (passed by reference)");
println("getmeta: get the metamap of a value (passed by value)");
let x = [123];
dumpln(getmeta(x));
setmeta(x.&, null);
dumpln(getmeta(x));

print("\n");

println("type(null) is " + repr(type(null)));
println("type(true) is " + repr(type(true)));
println("type(123) is " + repr(type(123)));
println("type(\"foo\") is " + repr(type("foo")));
println("type([123, 456]) is " + repr(type([123, 456])));
println("type({\"foo\": \"bar\"}) is " + repr(type({"foo": "bar"})));
println("type({\"foo\", \"bar\"}) is " + repr(type({"foo", "bar"})));
println("type(123.&) is " + repr(type(123.&)));
println("type(function() {}) is " + repr(type(function() {})));
println("type(println) is " + repr(type(println)));

print("\n");

println("123.is_inf() is " + repr(123.is_inf()));
println("(+Inf).is_inf() is " + repr((+Inf).is_inf()));
println("(-Inf).is_inf() is " + repr((-Inf).is_inf()));
println("NaN.is_inf() is " + repr(NaN.is_inf()));

println("123.is_nan() is " + repr(123.is_nan()));
println("Inf.is_nan() is " + repr(Inf.is_nan()));
println("NaN.is_nan() is " + repr(NaN.is_nan()));

println("123.is_integer() is " + repr(123.is_integer()));
println("123.5.is_integer() is " + repr(123.5.is_integer()));
println("Inf.is_integer() is " + repr(Inf.is_integer()));
println("NaN.is_integer() is " + repr(NaN.is_integer()));

println("(+123.45).trunc() is " + repr((+123.45).trunc()));
println("(-123.45).trunc() is " + repr((-123.45).trunc()));

println("(+123.45).round() is " + repr((+123.45).round()));
println("(-123.45).round() is " + repr((-123.45).round()));
println("(+123.54).round() is " + repr((+123.54).round()));
println("(-123.54).round() is " + repr((-123.54).round()));

println("(+123.45).floor() is " + repr((+123.45).floor()));
println("(-123.45).floor() is " + repr((-123.45).floor()));

println("(+123.45).ceil() is " + repr((+123.45).ceil()));
println("(-123.45).ceil() is " + repr((-123.45).ceil()));

print("\n");

println("\"foobar\".contains(\"foo\") is " + repr("foobar".contains("foo")));
println("\"foobar\".contains(\"bar\") is " + repr("foobar".contains("bar")));
println("\"foobar\".contains(\"baz\") is " + repr("foobar".contains("baz")));
println("\"foobar\".contains(\"\") is " + repr("foobar".contains("")));

println("\"foobar\".starts_with(\"foo\") is " + repr("foobar".starts_with("foo")));
println("\"foobar\".starts_with(\"bar\") is " + repr("foobar".starts_with("bar")));
println("\"foobar\".starts_with(\"\") is " + repr("foobar".starts_with("")));

println("\"foobar\".ends_with(\"foo\") is " + repr("foobar".ends_with("foo")));
println("\"foobar\".ends_with(\"bar\") is " + repr("foobar".ends_with("bar")));
println("\"foobar\".ends_with(\"\") is " + repr("foobar".ends_with("")));

println("\"foo\".trim() is " + repr("foo".trim()));
println(repr("\t\n foo\t\n ") + ".trim() is " + repr("\t\n foo\t\n ".trim()));

println("\"foo=bar\".find(\"=\") is " + repr("foo=bar".find("=")));
println("\"foo=bar\".find(\"nope\") is " + repr("foo=bar".find("nope")));
println("\"foo=foo\".find(\"foo\") is " + repr("foo=foo".find("foo")));

println("\"foo=bar\".rfind(\"=\") is " + repr("foo=bar".rfind("=")));
println("\"foo=bar\".rfind(\"nope\") is " + repr("foo=bar".rfind("nope")));
println("\"foo=foo\".rfind(\"foo\") is " + repr("foo=foo".rfind("foo")));

println("\"foo=bar\".slice(0, 3) is " + repr("foo=bar".slice(0, 3)));
println("\"foo=bar\".slice(4, 7) is " + repr("foo=bar".slice(4, 7)));

println("\"foo bar\".split(\" \") is " + repr("foo bar".split(" ")));
println("\"f o o b a r\".split(\" \") is " + repr("f o o b a r".split(" ")));
println("\"foobar\".split(\"oo\") is " + repr("foobar".split("oo")));
println("\"foobar\".split(\"o\") is " + repr("foobar".split("o")));
println("\"foobar\".split(\"baz\") is " + repr("foobar".split("baz")));

println("\", \".join([\"foo\", \"bar\", \"baz\"]) is " + repr(", ".join(["foo", "bar", "baz"])));
println("\", \".join([]) is " + repr(", ".join([])));
println("\"\".join([\"foo\", \"bar\", \"baz\"]) is " + repr("".join(["foo", "bar", "baz"])));
println("\"\".join([]) is " + repr("".join([])));

println("\"foo=bar\".cut(\"=\") is " + repr("foo=bar".cut("=")));
println("\"foo=bar\".cut(\"foo\") is " + repr("foo=bar".cut("foo")));
println("\"foo=bar\".cut(\"bar\") is " + repr("foo=bar".cut("bar")));
println("\"foo=bar\".cut(\"\") is " + repr("foo=bar".cut("")));
println("\"foo=bar\".cut(\"nope\") is " + repr("foo=bar".cut("nope")));
println("\"\".cut(\"\") is " + repr("".cut("")));

print("\n");

let x = [123, 456, 789];
println("initial vector x is " + repr(x));
println("x.count() is " + repr(x.count()));
println("x.push(\"foo\") ...");
x.push("foo");
println("x after push is " + repr(x));
println("x.pop() ...");
x.pop();
println("x after pop is " + repr(x));
println("x.insert(1, \"foo\") ...");
x.insert(1, "foo");
println("x after insert is " + repr(x));
println("x.remove(1) ...");
x.remove(1);
println("x after remove is " + repr(x));
println("x.slice(1, 3) is " + repr(x.slice(1, 3)));
println("x.contains(456) is " + repr(x.contains(456)));
println("x.contains(\"abc\") is " + repr(x.contains("abc")));
println("[\"foo\", \"bar\", \"baz\"].find(\"bar\") is " + repr(["foo", "bar", "baz"].find("bar")));
println("[\"foo\", \"bar\", \"baz\"].find(\"nope\") is " + repr(["foo", "bar", "baz"].find("nope")));
println("[\"foo\", \"bar\", \"foo\"].find(\"foo\") is " + repr(["foo", "bar", "foo"].find("foo")));
println("[\"foo\", \"bar\", \"baz\"].rfind(\"bar\") is " + repr(["foo", "bar", "baz"].rfind("bar")));
println("[\"foo\", \"bar\", \"baz\"].rfind(\"nope\") is " + repr(["foo", "bar", "baz"].rfind("nope")));
println("[\"foo\", \"bar\", \"foo\"].rfind(\"foo\") is " + repr(["foo", "bar", "foo"].rfind("foo")));
println("[\"foo\", \"bar\", \"baz\"].reversed() is " + repr(["foo", "bar", "baz"].reversed()));
println("[\"foo\", \"bar\", \"baz\"].sorted() is " + repr(["foo", "bar", "baz"].sorted()));

print("\n");

let x = {"a": 123, "b": 456, "c": 789};
println("initial map x is " + repr(x));
println("x.count() is " + repr(x.count()));
println("x.insert(\"foo\", \"bar\") ...");
x.insert("foo", "bar");
println("x after insert is " + repr(x));
println("x.remove(\"foo\") ...");
x.remove("foo");
println("x after remove is " + repr(x));
println("x.contains(\"b\") is " + repr(x.contains("b")));
println("x.contains(\"abc\") is " + repr(x.contains("abc")));

print("\n");

let x = {"a", "b", "c"};
println("initial set x is " + repr(x));
println("x.count() is " + repr(x.count()));
println("x.insert(\"foo\") ...");
x.insert("foo");
println("x after insert is " + repr(x));
println("x.remove(\"foo\") ...");
x.remove("foo");
println("x after remove is " + repr(x));
println("x.contains(\"b\") is " + repr(x.contains("b")));
println("x.contains(\"abc\") is " + repr(x.contains("abc")));

print("\n");

println("boolean(true) is " + repr(boolean(true)));
println("boolean(false) is " + repr(boolean(false)));
println("boolean(123) is " + repr(boolean(123)));
println("boolean(0) is " + repr(boolean(0)));
println("boolean(Inf) is " + repr(boolean(Inf)));
println("boolean(NaN) is " + repr(boolean(NaN)));
println("boolean(\"true\") is " + repr(boolean("true")));
println("boolean(\"false\") is " + repr(boolean("false")));
try { boolean(null); } else err { println("boolean(null) produces " + repr(err)); }
try { boolean("foo"); } else err { println("boolean(\"foo\") produces " + repr(err)); }
try { boolean(map{}); } else err { println("boolean(map{}) produces " + repr(err)); }

print("\n");

println("number(true) is " + repr(number(true)));
println("number(false) is " + repr(number(false)));
println("number(123) is " + repr(number(123)));
println("number(\"123\") is " + repr(number("123")));
println("number(\"+123\") is " + repr(number("+123")));
println("number(\"-123\") is " + repr(number("-123")));
println("number(\"123.4\") is " + repr(number("123.4")));
println("number(\"Inf\") is " + repr(number("Inf")));
println("number(\"INF\") is " + repr(number("INF")));
println("number(\"iNF\") is " + repr(number("iNF")));
println("number(\"NaN\") is " + repr(number("NaN")));
println("number(\"NAN\") is " + repr(number("NAN")));
println("number(\"nan\") is " + repr(number("nan")));
try { number(null); } else err { println("number(null) produces " + repr(err)); }
try { number("foo"); } else err { println("number(\"foo\") produces " + repr(err)); }
try { number(map{}); } else err { println("number(map{}) produces " + repr(err)); }

print("\n");

println("string(null) is " + repr(string(null)));
println("string(true) is " + repr(string(true)));
println("string(false) is " + repr(string(false)));
println("string(123) is " + repr(string(123)));
println("string(123.4) is " + repr(string(123.4)));
println("string(Inf) is " + repr(string(Inf)));
println("string(NaN) is " + repr(string(NaN)));
println("string(\"foo\") is " + repr(string("foo")));
println("string(map{}) is " + repr(string(map{})));
println("string(set{}) is " + repr(string(set{})));
println("string(123.&) is " + repr(string(123.&)));

print("\n");

println("vector(\"foo\") is " + repr(vector("foo")));
println("vector([123, 456, 789]) is " + repr(vector([123, 456, 789])));
println("vector({\"foo\": 123, \"bar\": 456, \"baz\": 789}) is " + repr(vector({"foo": 123, "bar": 456, "baz": 789})));
println("vector({\"foo\", \"bar\", \"baz\"}) is " + repr(vector({"foo", "bar", "baz"})));
try { vector(null); } else err { println("vector(null) produces " + repr(err)); }
try { vector(123); } else err { println("vector(123) produces " + repr(err)); }

print("\n");

assert(true); println("assert(true) does nothing");
try { assert(false); } else err { println("assert(false) produces " + repr(err)); }

print("\n");

let greeter = import("examples/greeter.lumpy");
println("import(\"examples/greeter.lumpy\") produces " + repr(greeter));
let greet = greeter::new("Juliet");
println("greeter::new(\"Juliet\") produces " + repr(greet));
greet(); # Say hello to Juliet!

print("\n");

println("read the `examples/greeter.lumpy` file with `fs::read`");
let module = fs::read("examples/greeter.lumpy");
println("```");
print(module);
println("```");

print("\n");

println("writing to `/dev/stdout` with file with `fs::write`");
let module = fs::write("/dev/stdout", "some text\n");

print("\n");

println("writing to `/dev/stdout` with file with `fs::append`");
let module = fs::append("/dev/stdout", "some text\n");

print("\n");

println("==================");
println("== Example Code ==");
println("==================");

println("Example Merge Sort");
let sort = function(x) {
    if x.count() <= 1 {
        return x;
    }
    let mid = (x.count() / 2).trunc();
    let lo = sort(x.slice(0, mid));
    let hi = sort(x.slice(mid, x.count()));
    let lo_index = 0;
    let hi_index = 0;
    let result = [];
    for _ in x.count() {
        if lo_index == lo.count() {
            result.push(hi[hi_index]);
            hi_index = hi_index + 1;
        }
        elif hi_index == hi.count() {
            result.push(lo[lo_index]);
            lo_index = lo_index + 1;
        }
        elif lo[lo_index] < hi[hi_index] {
            result.push(lo[lo_index]);
            lo_index = lo_index + 1;
        }
        else {
            result.push(hi[hi_index]);
            hi_index = hi_index + 1;
        }
    }
    return result;
};
let vec = [6, 8, 3, 1, 7, 2, 4, 5, 9];
dumpln(sort);
println("unsorded vector is " + repr(vec));
println("sorted vector is " + repr(sort(vec)));

print("\n");

println("Example Fibonacci");
let fibonacci = function(x) {
    if x == 0 {
        return 0;
    }
    elif x == 1 {
        return 1;
    }
    else {
        return fibonacci(x - 1) + fibonacci(x - 2);
    }
};
dumpln(fibonacci);
println("fibonacci(10) is " + repr(fibonacci(10)));

print("\n");

println("============================");
println("== Top-Level Error Traces ==");
println("============================");

let g = function() {
    let f = function() {
        error "oopsie";
    };
    f();
};
function() {
    let h = function() {
        g();
    };
    h();
}();
