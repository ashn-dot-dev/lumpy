try { dumpln( null         and null         ); } else err { dumpln(err); }
try { dumpln( true         and true         ); } else err { dumpln(err); }
try { dumpln( 123          and 123          ); } else err { dumpln(err); }
try { dumpln( "foo"        and "foo"        ); } else err { dumpln(err); }
try { dumpln( []           and []           ); } else err { dumpln(err); }
try { dumpln( map{}        and map{}        ); } else err { dumpln(err); }
try { dumpln( set{}        and set{}        ); } else err { dumpln(err); }
try { dumpln( 123.&        and 123.&        ); } else err { dumpln(err); }
try { dumpln( function(){} and function(){} ); } else err { dumpln(err); }
try { dumpln( println      and println      ); } else err { dumpln(err); }

print("\n");

dumpln(false and false);
dumpln(false and true);
dumpln(true and false);
dumpln(true and true);

print("\n");

let meta = {"and": function(lhs, rhs) { println("overload"); return true; }};
let x = 123;
let y = 456;
setmeta(x.&, meta);
try { x and y; } else err { dumpln(err); }
try { y and x; } else err { dumpln(err); }
################################################################################
# "attempted binary and operation with types `null` and `null`"
# true
# "attempted binary and operation with types `number` and `number`"
# "attempted binary and operation with types `string` and `string`"
# "attempted binary and operation with types `vector` and `vector`"
# "attempted binary and operation with types `map` and `map`"
# "attempted binary and operation with types `set` and `set`"
# "attempted binary and operation with types `reference` and `reference`"
# "attempted binary and operation with types `function` and `function`"
# "attempted binary and operation with types `function` and `function`"
#
# false
# false
# false
# true
#
# overload
# overload
